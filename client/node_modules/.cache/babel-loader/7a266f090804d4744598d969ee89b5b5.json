{"ast":null,"code":"/* eslint-disable react-hooks/exhaustive-deps */\nimport querySelectorAll from 'dom-helpers/querySelectorAll';\nimport React, { useCallback, useContext, useLayoutEffect, useMemo, useState, useRef } from 'react';\nexport const FocusListContext = /*#__PURE__*/React.createContext(null);\nconst defaultOpts = {\n  behavior: 'stop'\n};\nexport function useListOption(dataItem) {\n  const ctx = useContext(FocusListContext);\n  const prevElement = useRef(null); // this is a bit convoluted because we want to use a ref object, a callback ref\n  // causes an extra render which is fine except that it means the list hook for\n  // anchor items fires before elements are processed\n\n  const ref = useRef(null);\n  useLayoutEffect(() => () => {\n    ctx == null ? void 0 : ctx.map.delete(ref.current);\n  }, []);\n  useLayoutEffect(() => {\n    if (prevElement.current !== ref.current) {\n      ctx == null ? void 0 : ctx.map.delete(prevElement.current);\n    }\n\n    prevElement.current = ref.current;\n\n    if (ref.current && (ctx == null ? void 0 : ctx.map.get(ref.current)) !== dataItem) {\n      ctx == null ? void 0 : ctx.map.set(ref.current, dataItem);\n    }\n  });\n  const focused = dataItem === (ctx == null ? void 0 : ctx.focusedItem);\n  return [ref, focused, focused ? ctx == null ? void 0 : ctx.activeId : undefined];\n}\nexport const useFocusList = _ref => {\n  let {\n    scope: listRef,\n    anchorItem,\n    focusFirstItem: _focusFirstItem = false,\n    scopeSelector: _scopeSelector = '',\n    activeId\n  } = _ref;\n  const map = useMemo(() => new WeakMap(), []);\n  const [focusedItem, setFocusedItem] = useState();\n  const itemSelector = `${_scopeSelector} [data-rw-focusable]`.trim();\n\n  const get = () => {\n    const items = querySelectorAll(listRef.current, itemSelector);\n    return [items, items.find(e => e.dataset.rwFocused === '')];\n  };\n\n  const list = useMemo(() => {\n    return {\n      size() {\n        const [items] = get();\n        return items.length;\n      },\n\n      get,\n      toDataItem: el => map.get(el),\n\n      first() {\n        const [[first]] = get();\n        return first;\n      },\n\n      focus(el) {\n        if (!el || map.has(el)) setFocusedItem(el ? map.get(el) : undefined);\n      },\n\n      last() {\n        const [items] = get();\n        return items[items.length - 1];\n      },\n\n      next() {\n        let {\n          behavior\n        } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultOpts;\n        const [items, focusedItem] = get();\n        let nextIdx = items.indexOf(focusedItem) + 1;\n\n        if (nextIdx >= items.length) {\n          if (behavior === 'loop') return items[0];\n          if (behavior === 'clear') return undefined;\n          return focusedItem;\n        }\n\n        return items[nextIdx];\n      },\n\n      prev() {\n        let {\n          behavior\n        } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultOpts;\n        const [items, focusedItem] = get();\n        let nextIdx = Math.max(0, items.indexOf(focusedItem)) - 1;\n\n        if (nextIdx < 0) {\n          if (behavior === 'loop') return items[items.length - 1];\n          if (behavior === 'clear') return undefined;\n          return focusedItem;\n        }\n\n        return items[nextIdx];\n      }\n\n    };\n  }, []);\n  useLayoutEffect(() => {\n    if (!anchorItem) {\n      list.focus(null);\n      return;\n    }\n\n    const element = get()[0].find(el => list.toDataItem(el) === anchorItem);\n    list.focus(element);\n  }, [anchorItem]);\n  useLayoutEffect(() => {\n    if (!listRef.current) return;\n    const [, focusedElement] = get();\n    const hasItem = focusedElement != null;\n\n    if (!hasItem && _focusFirstItem || hasItem && !listRef.current.contains(focusedElement)) {\n      if (_focusFirstItem) list.focus(list.first());else list.focus(null);\n    }\n  });\n  const context = useMemo(() => ({\n    map,\n    focusedItem,\n    activeId\n  }), [focusedItem, activeId]);\n  list.context = context;\n  list.getFocused = useCallback(() => focusedItem, [focusedItem]);\n\n  list.hasFocused = () => focusedItem !== undefined;\n\n  return list;\n};","map":{"version":3,"sources":["C:/Users/ewart/OneDrive/Documents/GitHub/flightpub/client/node_modules/react-widgets/esm/FocusListContext.js"],"names":["querySelectorAll","React","useCallback","useContext","useLayoutEffect","useMemo","useState","useRef","FocusListContext","createContext","defaultOpts","behavior","useListOption","dataItem","ctx","prevElement","ref","map","delete","current","get","set","focused","focusedItem","activeId","undefined","useFocusList","scope","listRef","anchorItem","focusFirstItem","_focusFirstItem","scopeSelector","_scopeSelector","WeakMap","setFocusedItem","itemSelector","trim","items","find","e","dataset","rwFocused","list","size","length","toDataItem","el","first","focus","has","last","next","nextIdx","indexOf","prev","Math","max","element","focusedElement","hasItem","contains","context","getFocused","hasFocused"],"mappings":"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","sourcesContent":["/* eslint-disable react-hooks/exhaustive-deps */\nimport querySelectorAll from 'dom-helpers/querySelectorAll';\nimport React, { useCallback, useContext, useLayoutEffect, useMemo, useState, useRef } from 'react';\nexport const FocusListContext = /*#__PURE__*/React.createContext(null);\nconst defaultOpts = {\n  behavior: 'stop'\n};\nexport function useListOption(dataItem) {\n  const ctx = useContext(FocusListContext);\n  const prevElement = useRef(null); // this is a bit convoluted because we want to use a ref object, a callback ref\n  // causes an extra render which is fine except that it means the list hook for\n  // anchor items fires before elements are processed\n\n  const ref = useRef(null);\n  useLayoutEffect(() => () => {\n    ctx == null ? void 0 : ctx.map.delete(ref.current);\n  }, []);\n  useLayoutEffect(() => {\n    if (prevElement.current !== ref.current) {\n      ctx == null ? void 0 : ctx.map.delete(prevElement.current);\n    }\n\n    prevElement.current = ref.current;\n\n    if (ref.current && (ctx == null ? void 0 : ctx.map.get(ref.current)) !== dataItem) {\n      ctx == null ? void 0 : ctx.map.set(ref.current, dataItem);\n    }\n  });\n  const focused = dataItem === (ctx == null ? void 0 : ctx.focusedItem);\n  return [ref, focused, focused ? ctx == null ? void 0 : ctx.activeId : undefined];\n}\nexport const useFocusList = ({\n  scope: listRef,\n  anchorItem,\n  focusFirstItem: _focusFirstItem = false,\n  scopeSelector: _scopeSelector = '',\n  activeId\n}) => {\n  const map = useMemo(() => new WeakMap(), []);\n  const [focusedItem, setFocusedItem] = useState();\n  const itemSelector = `${_scopeSelector} [data-rw-focusable]`.trim();\n\n  const get = () => {\n    const items = querySelectorAll(listRef.current, itemSelector);\n    return [items, items.find(e => e.dataset.rwFocused === '')];\n  };\n\n  const list = useMemo(() => {\n    return {\n      size() {\n        const [items] = get();\n        return items.length;\n      },\n\n      get,\n      toDataItem: el => map.get(el),\n\n      first() {\n        const [[first]] = get();\n        return first;\n      },\n\n      focus(el) {\n        if (!el || map.has(el)) setFocusedItem(el ? map.get(el) : undefined);\n      },\n\n      last() {\n        const [items] = get();\n        return items[items.length - 1];\n      },\n\n      next({\n        behavior\n      } = defaultOpts) {\n        const [items, focusedItem] = get();\n        let nextIdx = items.indexOf(focusedItem) + 1;\n\n        if (nextIdx >= items.length) {\n          if (behavior === 'loop') return items[0];\n          if (behavior === 'clear') return undefined;\n          return focusedItem;\n        }\n\n        return items[nextIdx];\n      },\n\n      prev({\n        behavior\n      } = defaultOpts) {\n        const [items, focusedItem] = get();\n        let nextIdx = Math.max(0, items.indexOf(focusedItem)) - 1;\n\n        if (nextIdx < 0) {\n          if (behavior === 'loop') return items[items.length - 1];\n          if (behavior === 'clear') return undefined;\n          return focusedItem;\n        }\n\n        return items[nextIdx];\n      }\n\n    };\n  }, []);\n  useLayoutEffect(() => {\n    if (!anchorItem) {\n      list.focus(null);\n      return;\n    }\n\n    const element = get()[0].find(el => list.toDataItem(el) === anchorItem);\n    list.focus(element);\n  }, [anchorItem]);\n  useLayoutEffect(() => {\n    if (!listRef.current) return;\n    const [, focusedElement] = get();\n    const hasItem = focusedElement != null;\n\n    if (!hasItem && _focusFirstItem || hasItem && !listRef.current.contains(focusedElement)) {\n      if (_focusFirstItem) list.focus(list.first());else list.focus(null);\n    }\n  });\n  const context = useMemo(() => ({\n    map,\n    focusedItem,\n    activeId\n  }), [focusedItem, activeId]);\n  list.context = context;\n  list.getFocused = useCallback(() => focusedItem, [focusedItem]);\n\n  list.hasFocused = () => focusedItem !== undefined;\n\n  return list;\n};"]},"metadata":{},"sourceType":"module"}